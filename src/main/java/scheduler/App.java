/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package scheduler;

import org.optaplanner.core.api.solver.Solver;
import org.optaplanner.core.api.solver.SolverFactory;
import scheduler.model.*;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

import static java.util.stream.Collectors.toList;

public class App {

    public static void main(String[] args) {
        Schedule problem = createSchedule();

        SolverFactory<Schedule> solverFactory = SolverFactory.createFromXmlResource("scheduler/config.xml");

        System.out.println("#######" + problem);

        System.out.println("####### SOLVING #######");

        Solver<Schedule> solver = solverFactory.buildSolver();
        Schedule solution = solver.solve(problem);

        System.out.println("####### FINISHED SOLVING #######");

        System.out.println("#######" + solution.hashCode() + "=" + solution);
    }

    private static Schedule createSchedule() {
        Schedule problem = new Schedule();
        Pool pool = new Pool();
        pool
                .addVirtualMachine(new VirtualMachine(1L, true))
                .addVirtualMachine(new VirtualMachine(2L, true))
                .addVirtualMachine(new VirtualMachine(3L, true))
                .addVirtualMachine(new VirtualMachine(4L, false)); // TODO: weight =Â prefer started machines
        problem.setPools(List.of(pool));
        Tenant tenant1 = new Tenant("t-1", 10);
        MarkerList list1 = new MarkerList("list1", tenant1);
        Random random = new SecureRandom();
        Set<Long> ids = new TreeSet<>();
        list1.addMarker(new Marker("m1", 5 * 60, LocalDateTime.now().plusHours(1)));
        list1.addMarker(new Marker("m2", 5 * 60, LocalDateTime.now().plusHours(4)));
        list1.addMarker(new Marker("m3", 3 * 60, LocalDateTime.now().plusHours(1)));
        list1.addMarker(new Marker("m4", 1 * 60, LocalDateTime.now().plusHours(4)));
        List<MarkerNesting> nestings = list1.getMarkers().stream().map(m -> {
            Long id = nextId(random, ids);
            return new MarkerNesting(id, m);
        }).collect(toList());
        problem.setMarkerNestings(nestings);

        return initializeSolution(problem);
    }

    private static Long nextId(Random rng, Set<Long> alreadyUsed) {
        Long id;
        do {
            id = Math.abs(rng.nextLong()) % 1000;
        } while (alreadyUsed.contains(id));
        alreadyUsed.add(id);
        return id;
    }

    private static Schedule initializeSolution(Schedule problem) {
        VirtualMachine machine = problem.getPools().get(0).getMachines().get(0);
        List<MarkerNesting> markerNestings = problem.getMarkerNestings();
        markerNestings.get(0).setPreviousTaskChainLink(machine);
        machine.setNextMarkerNesting(markerNestings.get(0));
        for (int i = 1; i < markerNestings.size(); i++) {
            MarkerNesting prev = markerNestings.get(i - 1);
            MarkerNesting current = markerNestings.get(i);
            current.setVirtualMachine(machine);
            prev.setNextMarkerNesting(current);
            current.setPreviousTaskChainLink(prev);
        }
        return problem;
    }
}
